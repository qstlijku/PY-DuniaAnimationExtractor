LittleEndian();
FSkip(32);

uint32 signature;
uint sectionLength;

float unk;

float ClipLength;

ushort count0;
ushort unk0;
ushort unk1;
ushort unk2;
ushort unk3;
ushort unk4;
ushort unk5;
ushort unk6;
ushort pad1;
ushort pad2;
typedef struct {
    uint sectionLength;
    float ClipLength;
    ushort count0;
    ushort unk0;
    ushort unk1;
    ushort unk2;
    ushort unk3;
    ushort unk4;
    ushort unk5;
    ushort unk6;
    local int i = 0;
    struct {
        for (i = 0; i < 11; i++)
            uint unkArrayA; //+16 offset to get section offsets
    } unkArrayA;
        ushort frameCount;
        ushort zero;
    struct {
        for (i = 0; i < count0; i++)
            uint unkArrayB;
    } boneHashes;
    struct {
        for (i = 0; i < count0; i++)
            ubyte unkArrayD;
    } unkArrayD;
    FSeek(FTell() + (4 - (FTell() % 4)) % 4);
    
    /*
        ushort zero3;
    struct {
        for (i = 0; i < frameCount; i++)
            ushort frameArray;
    } frames;
    */
    
    
    
    local uint array_size[11];
    local int j = 0;
    for (i = 0; i < 11; i++) {
        while (this.unkArrayA.unkArrayA[i] == 0)
        {
            if ( i == 10 ) {
                break;
            } else {
                i++;
            }
        }
    
        j = i;
        if (j != 10) {
            while (this.unkArrayA.unkArrayA[j + 1] == 0)
            {
                j++;
                if ( j == 10 ) {
                    break;
                }
            }
        }
        
        if (j != 10) {
            array_size[i] = this.unkArrayA.unkArrayA[j + 1] - this.unkArrayA.unkArrayA[i];
        } else {
            array_size[i] = sectionLength - this.unkArrayA.unkArrayA[i];
        }
    }
    
    for (i = 0; i < 11; i++) {
        if (this.unkArrayA.unkArrayA[i] == 0) {
            array_size[i] = 0;
        }
    }
    
    local uint total_size = 0;
    
    //FSeek(unkArrayA.unkArrayA[0]+16);
    
    struct {
        //ubyte data[array_size[0]];
        ushort frame[frameCount+1];
    } Section1;
    
    struct {
        ubyte data[array_size[1]];
    } Section2;
    
    struct {
        //ubyte data[array_size[2]];
        if (array_size[2] != 0) {
            local uint offset_table_size = ReadUInt(FTell());
            uint offset[offset_table_size/4];
            for (i = 1; i < offset_table_size/4; i++) {
                struct {
                    ubyte data[offset[i] - offset[i-1]];
                } unk_section;
            }
            //FSeek(FTell() + (4 - (FTell() % 4)) % 4);
            FSkip(array_size[2] - offset[offset_table_size/4 - 1]);
        }
    } Section3;
    
    struct {
        //ubyte data[array_size[3]];
        if (array_size[3] != 0) {
            local uint offset_table_size = ReadUInt(FTell());
            uint offset[offset_table_size/4];
            for (i = 1; i < offset_table_size/4; i++) {
                struct {
                    ubyte data[offset[i] - offset[i-1]];
                } unk_section;
            }
            FSkip(array_size[3] - offset[offset_table_size/4 - 1]);
            //FSeek(FTell() + (2 - (FTell() % 2)) % 2);
        }
    } Section4;
    
    struct {
        ubyte data[array_size[4]];
    } Section5;
    
    struct {
        ubyte data[array_size[5]];
    } Section6;
    
    struct {
        //ubyte data[array_size[6]];
        if (array_size[6] != 0) {
            local uint offset_table_size = ReadUInt(FTell());
            uint offset[offset_table_size/4];
            for (i = 1; i < offset_table_size/4; i++) {
                struct {
                    ubyte data[offset[i] - offset[i-1]];
                } unk_section;
            }
            FSkip(array_size[6] - offset[offset_table_size/4 - 1]);
            //FSeek(FTell() + (2 - (FTell() % 2)) % 2);
        }
    } Section7;
    
    struct {
        //ubyte data[array_size[7]];
        if (array_size[7] != 0) {
            local uint offset_table_size = ReadUInt(FTell());
            uint offset[offset_table_size/4];
            for (i = 1; i < offset_table_size/4; i++) {
                struct {
                    ubyte data[offset[i] - offset[i-1]];
                } unk_section;
            }
            FSkip(array_size[7] - offset[offset_table_size/4 - 1]);
            //FSeek(FTell() + (2 - (FTell() % 2)) % 2);
        }
    } Section8;
    
    struct {
        ubyte data[array_size[8]];
    } Section9;
    
    struct {
        //ubyte data[array_size[9]];
        //markup
        if (array_size[9] != 0) {
            local uint total_event = 0;
            local ushort has_next = ReadUShort(FTell()+10);
            while (has_next > 0) {
                struct {
                    float time;
                    uint type;
                    ushort external_size;
                    ushort next_size;
                    if (type == 1) {
                        uint poseType;
                    } else if (type == 2) {
                        ubyte data[external_size];
                        FSeek(FTell() + (4 - (FTell() % 4)) % 4);
                    }
                    has_next = next_size;
                    total_event++;
                } event;
            }
        }
    } Section10;
    
    struct {
        ubyte data[array_size[10]];
    } Section11;
    
    FSeek(FTell() + (4 - (FTell() % 4)) % 4);
} AnimChunk <optimize=false>;

local int i = 0;
struct {
    for (i = 0; i < 11; i++)
        uint unkArrayA; //+16 offset to get section offsets
} unkArrayA;
float pad;
    ushort frameCount;
    ushort zero;
struct {
    for (i = 0; i < count0; i++)
        uint unkArrayB;
} boneHashes;
struct {
    for (i = 0; i < count0; i++)
        ubyte unkArrayD;
} unkArrayD;
FSeek(FTell() + (4 - (FTell() % 4)) % 4);

/*
    ushort zero3;
struct {
    for (i = 0; i < frameCount; i++)
        ushort frameArray;
} frames;
*/



local uint array_size[11];
local int j = 0;
for (i = 0; i < 11; i++) {
    while (unkArrayA.unkArrayA[i] == 0)
    {
        if ( i == 10 ) {
            break;
        } else {
            i++;
        }
    }

    j = i;
    if (j != 10) {
        while (unkArrayA.unkArrayA[j + 1] == 0)
        {
            j++;
            if ( j == 10 ) {
                break;
            }
        }
    }
    
    if (j != 10) {
        array_size[i] = unkArrayA.unkArrayA[j + 1] - unkArrayA.unkArrayA[i];
    } else {
        array_size[i] = sectionLength - unkArrayA.unkArrayA[i];
    }
}

for (i = 0; i < 11; i++) {
    if (unkArrayA.unkArrayA[i] == 0) {
        array_size[i] = 0;
    }
}

local uint total_size = 0;

FSeek(unkArrayA.unkArrayA[0]+16);

struct {
    //ubyte data[array_size[0]];
    ushort frame[frameCount+1];
} Section1;

struct {
    ubyte data[array_size[1]];
} Section2;

struct {
    //ubyte data[array_size[2]];
    if (array_size[2] != 0) {
        local uint offset_table_size = ReadUInt(FTell());
        uint offset[offset_table_size/4];
        for (i = 1; i < offset_table_size/4; i++) {
            struct {
                ubyte data[offset[i] - offset[i-1]];
            } unk_section;
        }
        //FSeek(FTell() + (4 - (FTell() % 4)) % 4);
        FSkip(array_size[2] - offset[offset_table_size/4 - 1]);
    }
} Section3;

struct {
    //ubyte data[array_size[3]];
    if (array_size[3] != 0) {
        local uint offset_table_size = ReadUInt(FTell());
        uint offset[offset_table_size/4];
        for (i = 1; i < offset_table_size/4; i++) {
            struct {
                ubyte data[offset[i] - offset[i-1]];
            } unk_section;
        }
        FSkip(array_size[3] - offset[offset_table_size/4 - 1]);
        //FSeek(FTell() + (2 - (FTell() % 2)) % 2);
    }
} Section4;

struct {
    ubyte data[array_size[4]];
} Section5;

struct {
    ubyte data[array_size[5]];
} Section6;

struct {
    //ubyte data[array_size[6]];
    if (array_size[6] != 0) {
        local uint offset_table_size = ReadUInt(FTell());
        uint offset[offset_table_size/4];
        for (i = 1; i < offset_table_size/4; i++) {
            struct {
                ubyte data[offset[i] - offset[i-1]];
            } unk_section;
        }
        FSkip(array_size[6] - offset[offset_table_size/4 - 1]);
        //FSeek(FTell() + (2 - (FTell() % 2)) % 2);
    }
} Section7;

struct {
    //ubyte data[array_size[7]];
    if (array_size[7] != 0) {
        local uint offset_table_size = ReadUInt(FTell());
        uint offset[offset_table_size/4];
        for (i = 1; i < offset_table_size/4; i++) {
            struct {
                ubyte data[offset[i] - offset[i-1]];
            } unk_section;
        }
        FSkip(array_size[7] - offset[offset_table_size/4 - 1]);
        //FSeek(FTell() + (2 - (FTell() % 2)) % 2);
    }
} Section8;

struct {
    //ubyte data[array_size[8]];
    if (array_size[8] != 0) {
        uint animpart_count;
        //uint zero;
        //uint animpart_size;
        //ubyte animpart_data[animpart_size-8];
        
        struct {
            uint zero1;
            uint offset_to_animfile;
            uint zero2;
            float unk0;
            uint parent;
            uint handle;
            uint file;
            ubyte type_parent;
            ubyte type_handle;
            ushort unk1;
        } anchor[animpart_count];
        
        ubyte animpart_string[anchor[0].offset_to_animfile-32*animpart_count];
            
        
        for (j = 0; j < animpart_count; j++) {
            struct {
                local uint baseoffset = FTell();
                uint hash;
                uint signature;
                AnimChunk ani;
            } animpart;
        }
    }
} Section9;

struct {
    //ubyte data[array_size[9]];
    //markup
    if (array_size[9] != 0) {
        local uint total_event = 0;
        local ushort has_next = ReadUShort(FTell()+10);
        while (has_next > 0) {
            struct {
                float time;
                uint type;
                ushort external_size;
                ushort next_size;
                if (type == 1) {
                    uint poseType;
                } else if (type == 2) {
                    ubyte data[external_size];
                    FSeek(FTell() + (4 - (FTell() % 4)) % 4);
                }
                has_next = next_size;
                total_event++;
            } event;
        }
    }
} Section10;

struct {
    ubyte data[array_size[10]];
} Section11;

/*
local uint section_size,total_size;
if (unkArrayA.unkArrayA[0] != 0) {
    FSeek(unkArrayA.unkArrayA[0]+16);
    
    i = 1;
    while (unkArrayA.unkArrayA[i] == 0)
    {
        i++;
    }
    section_size = unkArrayA.unkArrayA[i] - unkArrayA.unkArrayA[0];
    total_size += section_size;
    
    struct {
        ubyte data[section_size];
    } Section1;
}

if (unkArrayA.unkArrayA[1] != 0) {
    FSeek(unkArrayA.unkArrayA[0]+16+total_size);
    
    i = 2;
    while (unkArrayA.unkArrayA[i] == 0)
    {
        i++;
    }
    section_size = unkArrayA.unkArrayA[i] - unkArrayA.unkArrayA[1];
    total_size += section_size;
    
    struct {
        ubyte data[section_size];
    } Section2;
}

if (unkArrayA.unkArrayA[2] != 0) {
    FSeek(unkArrayA.unkArrayA[0]+16+total_size);
    
    i = 3;
    while (unkArrayA.unkArrayA[i] == 0)
    {
        i++;
    }
    section_size = unkArrayA.unkArrayA[i] - unkArrayA.unkArrayA[2];
    total_size += section_size;
    
    struct {
        ubyte data[section_size];
    } Section3;
}

if (unkArrayA.unkArrayA[3] != 0) {
    FSeek(unkArrayA.unkArrayA[0]+16+total_size);
    
    i = 4;
    while (unkArrayA.unkArrayA[i] == 0)
    {
        i++;
    }
    section_size = unkArrayA.unkArrayA[i] - unkArrayA.unkArrayA[3];
    total_size += section_size;
    
    struct {
        ubyte data[section_size];
    } Section4;
}

if (unkArrayA.unkArrayA[4] != 0) {
    FSeek(unkArrayA.unkArrayA[0]+16+total_size);
    
    i = 5;
    while (unkArrayA.unkArrayA[i] == 0)
    {
        i++;
    }
    section_size = unkArrayA.unkArrayA[i] - unkArrayA.unkArrayA[4];
    total_size += section_size;
    
    struct {
        ubyte data[section_size];
    } Section5;
}

if (unkArrayA.unkArrayA[5] != 0) {
    FSeek(unkArrayA.unkArrayA[0]+16+total_size);
    
    i = 6;
    while (unkArrayA.unkArrayA[i] == 0)
    {
        i++;
    }
    section_size = unkArrayA.unkArrayA[i] - unkArrayA.unkArrayA[5];
    total_size += section_size;
    
    struct {
        ubyte data[section_size];
    } Section6;
}

if (unkArrayA.unkArrayA[6] != 0) {
    FSeek(unkArrayA.unkArrayA[0]+16+total_size);
    
    i = 7;
    while (unkArrayA.unkArrayA[i] == 0)
    {
        i++;
    }
    section_size = unkArrayA.unkArrayA[i] - unkArrayA.unkArrayA[6];
    total_size += section_size;
    
    struct {
        ubyte data[section_size];
    } Section7;
}
*/